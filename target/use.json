{"noir_version":"0.35.0+999071b80e61a37cb994a4e359eabbac27cd53f1","hash":12831869037149562577,"abi":{"parameters":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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VGQeI0V00oiKzGM4h04aUZF5jLnQSSMqMo+BETppREXmMXpBJ42oyDyGGOikERWZxzgAnTSiIkP07BdEz35B9OwXRM9+QfTsF0TPfkH07BdEz35B9OwXRM9+QfTsF0TPfkH07BdEz35B9OwXRM9+QfTsF0TPfkH07BdEz35B9OwXRM9+QfTsF0TPfkH07BdEz/6K6NlfET37K6Jnf0X07K8bI5IGVGQV0bO/Inr2V0TP/oro2V8RPfsromd/RfTsr4ie/RXRs78ievZXRM/+iujZXxE9+yuiZ39F9OyviJ79FdGzvyJ69ldEz/6K6NlfET37K6Jnf0X07K+Inv0V0bO/Inr2V0TP/oro2V8RPfsromd/RfTsr4ie/RXRs78ievZXRM/+iujZXxE9+yuiZ39F9OyviJ79FdGzvyJ69ldEz/6K6NlfET37K6Jnf0X07K+Inv0V0bO/Inr2V0TP/oro2V8RPfsromd/RfTsr4ie/RXRs78ievZXRM/+iujZXxE9+yuiZ39F9OyviJ79FdGzvyJ69ldEz/6K6NlfET37K6Jnf0X07K+Inv0V0bO/Inr2V0TP/oro2V8RPfsromd/RfTsr4ie/RXRs78ievZXRM/+iujZXxE9+yuiZ39F9OyviJ79FdGzvyJ69ldEz/6K6NlfET37K6BnP2+Anv07aTxFtpPGU2Q7aTxFtpNmRNJ4imwnjafIdtJ4imwnjafIdtKIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9KIigzQs38njajIAD37d9IOFVnZ4vb6fNl/gf9O+vzxtKWfH04x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4/5ZH/fP+rh/1sf9sz7un/Vx/6yP+2d93D/r4/5ZH/fP+rh/1sf9sz7un/Vx/6yP+2d93D/r4/5ZH/fP+rh/1sf9sz7un/Vx/6yP+2d93D/r4/5ZH/fP+rh/1sf9sz7un/Vx/6yP+2d93D/r4/5ZH/fP+rh/1sf9sz7un/Vx/6yP+2d93D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+tL/bO+1D/rS/2zvtQ/60v9s77UP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/68v9s77cP+vL/bO+3D/ry/2zvtw/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rK/2zvtI/6yv9s77SP+sr/bO+0j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9sz7pn/VJ/6xP+md90j/rk/5Zn/TP+qR/1if9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur/bO+2j/rq/2zvto/66v9s77aP+ur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SSe9FsxsXr5OY8owTM2L4kkvKDN70s9tpp5UbpNp8qQBWq+oc/K097ZeaOfkae9tvYbNydPe22bqae9tM/W097ZexOfkaQ7Qem2fk6e79dZL/pw99dPWq+mcPd35tpl6uj9tM/WkkVrmBDzlJXk7TH9vZcDZk0ZqvYDP2ZNGajP1pJHaTNfVSD/gWxc+zTe3uVhXMwp86xJFgW9ddyjwrYsJBT6vDd9621fgW+/lCnzrDbrpJcDFetdV4Jvvuk34Yr7rtuGb77pt+Oa7bhu+qa77A5GpRvoDkane+AORqXb3A9H9HSzy8bNAzEW7DMrx6f2fp1fTPuCNMRV+XRr+B1w3psIPa8OnteHHteHz2vDT2vDz2vDX7rp17a5bl+66aVu666Zt6a6btqW7btqW7rppW7rrpm3prpu2pbtu2pbuuonNr/36GjWQhHCCb736TROcxLdrHon8qqfElBT4+2/Qr7+9/zOf4Nel4d///Hon/Jpf747s8vIMP6wNn9aGH9eGz8vA38X9GX5aG362Dp/5WDzffyf6Cb+sDd9611XgW++6bfjZfNdtwzffddvwzXfdNnzzXbcN33zXbcM333Xb8NfuunntrpvX7rp57a5b1u66Ze2uW9buumXtrnv/09hz4a/ddcvaXbes3XXL2l23rN11Ze2uK2t3XVm768raXff+R7fnwl+768raXVfW7rqydteVtbtuXbvr1rW7bl2769a1u+79T5DPhb92161rd926dteta3fdunTXzdvSXTdvS3fdvC3ddfO2dNfN29JdN29Ld928Ld1187Z0183b0l03b2t33bB21w1rd92wdtcNa3fd+yOE58Jfu+uGtbtuWLvrhrW7bli769LaXZfW7rq0dteltbvu/RHCc+Gv3XVp7a5La3ddWrvr0tpdN67ddePaXTeu3XXj2l33/vTvufDX7rpx7a4b1+66ce2uG9fuurx21+W1uy6v3XV57a57vzvSXPhrd11eu+vy2l3XvDeVAn/trmvfm6oNf+2ua9+bqg1/7a5r35uqDX/trru2N1Ve25sqr+1Nldf2pspre1Pltb2p8treVHltb6q8tjdVXtubKq/tTZXX9qbKa3tT5bW9qfLa3lR5bW+qvLY3VV7bmyqv7U2V1/amymt7U+W1vany2t5UeW1vqry2N1Ve25sqr+1Nldf2pspre1Pltb2p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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"37":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {\n    crate::assert_constant(proof_type);\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"70":{"source":"use dep::bignum::{\n    bignum::BigNum, runtime_bignum::RuntimeBigNum, fields::{bn254Fq::BN254_Fq_Params, U256::U256Params},\n    params::{BigNumParams, BigNumParamsGetter},\n    utils::u60_representation::U60Repr\n};\n\n\n//**************************************************************************\n//**************************************************************************\n//**************************************************************************\n// THIS FILE IS ONLY COMPATIBLE WITH DEP:\n// bignum = {tag = \"mc/alt-refactor\", git = \"https://github.com/noir-lang/noir-bignum\"}\n//**************************************************************************\n//**************************************************************************\n//**************************************************************************\n\n\nstruct Test2048Params{}\n\n// See https://github.com/noir-lang/noir/issues/6172\n#[test]\nfn silence_warning() {\n    let _  = Test2048Params {};\n}\n\nimpl BigNumParamsGetter<18, 2048> for Test2048Params {\n    fn get_params() -> BigNumParams<18, 2048> {\n        let has_multiplicative_inverse = false;\n        let modulus: [Field; 18] = [\n            0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n            0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n            0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n            0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n            0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n            0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n            0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n            0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n            0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n            0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n            0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n            0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n            0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n            0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n            0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n            0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n            0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n            0x00000000000000000000000000000000000000000000000000000000000000b8\n        ];\n        let redc_param: [Field; 18] = [\n            0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n            0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n            0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n            0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n            0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n            0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n            0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n            0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n            0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n            0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n            0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n            0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n            0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n            0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n            0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n            0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n            0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n            0x0000000000000000000000000000000000000000000000000000000000000162\n        ];\n        BigNumParams::new(\n            has_multiplicative_inverse,\n            modulus,\n            redc_param\n        )\n    }\n}\n\ntype BN254_Fq = BigNum<3, 254, BN254_Fq_Params>;\ntype U256_Fq = BigNum<3, 257, BN254_Fq_Params>;\n\n// fn main(x: u8) {\n//     let _a: BN254_Fq = BigNum::__derive_from_seed([x,2,3,4]);\n//     let mut a = _a;\n//     // let mut b = a;\n//     // let mut c = a;\n//     for _i in 0..10 {\n//         // a = unsafe { a.__add(b) };\n//         // b = unsafe { a.__mul(c) };\n//         // c = unsafe { c.__mul(c) };\n//         // BigNum::evaluate_quadratic_expression([[a]], [[false]], [[b]], [[false]], [c], [true]);\n//         a = a.mul(a);\n//         // b = b.mul(c);\n//         // c = b.mul(a);\n//     }\n// }\n\n// #[test]\n// fn test_bn254_fq() {\n//     // let a: BN254_Fq = BigNum::__derive_from_seed([1,2,3,4]);\n//     main(1);\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\n\n\n\n\n// THIS IS THE BIGNUM VERSION\n\ntype BigNum_2048 = BigNum<18, 2048, Test2048Params>;\n\n// fn main(x: u8) {\n//     let _a: BigNum_2048 = BigNum::__derive_from_seed([x,2,3,4]);\n//     let mut a = _a;\n//     // let mut b = a;\n//     // let mut c = a;\n//     for _i in 0..10 {\n//         // a = unsafe { a.__add(b) };\n//         // b = unsafe { a.__mul(c) };\n//         // c = unsafe { c.__mul(c) };\n//         // BigNum::evaluate_quadratic_expression([[a]], [[false]], [[b]], [[false]], [c], [true]);\n//         a = a.mul(a);\n//         // b = b.mul(c);\n//         // c = b.mul(a);\n//     }\n// }\n\n// #[test]\n// fn test_2048() {\n//     // let a: BigNum_2048 = BigNum::__derive_from_seed([1,2,3,4]);\n//     main(1);\n// }\n\n\n\n\n\n\n\ncomptime fn get_2048_BN_params() -> BigNumParams<18, 2048> {\n    let has_multiplicative_inverse = false;\n    let modulus: [Field; 18] = [\n        0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n        0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n        0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n        0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n        0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n        0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n        0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n        0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n        0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n        0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n        0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n        0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n        0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n        0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n        0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n        0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n        0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n        0x00000000000000000000000000000000000000000000000000000000000000b8\n    ];\n    let redc_param: [Field; 18] = [\n        0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n        0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n        0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n        0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n        0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n        0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n        0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n        0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n        0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n        0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n        0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n        0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n        0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n        0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n        0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n        0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n        0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n        0x0000000000000000000000000000000000000000000000000000000000000162\n    ];\n    BigNumParams::new(\n        has_multiplicative_inverse,\n        modulus,\n        redc_param\n    )\n}\n\ncomptime global MY_RUNTIME_BIGNUM_PARAMS: BigNumParams<18, 2048> = BigNumParams {\n    has_multiplicative_inverse: false,\n    modulus: [\n        0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n        0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n        0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n        0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n        0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n        0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n        0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n        0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n        0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n        0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n        0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n        0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n        0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n        0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n        0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n        0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n        0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n        0x00000000000000000000000000000000000000000000000000000000000000b8\n    ],\n    double_modulus: [0x0181432f4b5c1f9b9d60a592e64c29fc, 0x01cad5c06884650684448723157077c6, 0x01d7eb21b4914f820e16fab557558cef, 0x01199c73ea604716c0de49652dc57b51, 0x0103c3fdf37738387d5b31e44de37f3f, 0x015b183902dc25c1da26f20abc6e757d, 0x019d7d01c8e9eea7553a28c3886a247a, 0x015dcb4319ddbdf11a22b5172782cf5a, 0x014d17507894cb8860e84ff892bb3c88, 0x01ba4eef24d090ccf6fbef3e684c73a7, 0x01e8aa0e992d0ab9400d0cd1dfcfb47a, 0x01bbb74d6617782d17f674244be4faca, 0x01b23fd8909e6ce0ea4826779ade84af, 0x01b2c836eacecd5dd7cccf03ba03a0c3, 0x01b178bd5fe962cbc2857f3c4901dd75, 0x01ccf472c9e11c0dbeee59cc964534e3, 0x01383fb63120ee237fc7c7839f230729, 0x0170],\n    modulus_u60: U60Repr { limbs: [1058436937605846270, 867533891523640540, 153759629660666851, 456743741275973684, 507637211389937272, 486205199909288976, 31284071869103529, 57671168680933558, 1057669653304819616, 8479363271606723, 942229811013040831, 781587600470257166, 764789921859047997, 931092896005715258, 941633352623024045, 787666047433830280, 32695061814550084, 173593660756483139, 828090169652820436, 995989829823268455, 1836635119934013, 1100374146487440842, 863347603192053093, 422698909584572776, 370442216921842264, 401381961810274055, 857486586516983906, 402581472381659886, 90845628438998715, 399630605048551006, 1114408800412146290, 461517352795168877, 1145009151832851349, 703121955796513051, 184, 0] },\n    modulus_u60_x4: U60Repr { limbs: [1058436937605846270, 867533891523640540, 153759629660666851, 456743741275973684, 507637211389937272, 486205199909288976, 31284071869103529, 57671168680933558, 1057669653304819616, 8479363271606723, 942229811013040831, 781587600470257166, 764789921859047997, 931092896005715258, 941633352623024045, 787666047433830280, 32695061814550084, 173593660756483139, 828090169652820436, 995989829823268455, 1836635119934013, 1100374146487440842, 863347603192053093, 422698909584572776, 370442216921842264, 401381961810274055, 857486586516983906, 402581472381659886, 90845628438998715, 399630605048551006, 1114408800412146290, 461517352795168877, 1145009151832851349, 703121955796513051, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] },\n    redc_param: [\n        0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n        0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n        0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n        0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n        0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n        0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n        0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n        0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n        0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n        0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n        0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n        0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n        0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n        0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n        0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n        0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n        0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n        0x0000000000000000000000000000000000000000000000000000000000000162\n    ]\n};\n\n\n// THIS IS THE RUNTIME-BIGNUM VERSION\n\ntype MyRuntimeBigNum = RuntimeBigNum<18, 2048>;\n\nfn main(x: u8) {\n    let params = comptime {MY_RUNTIME_BIGNUM_PARAMS};\n    println(params);\n    let _a: MyRuntimeBigNum = RuntimeBigNum::__derive_from_seed(params, [x,2,3,4]);\n    let mut a = _a;\n    // let mut b = a;\n    // let mut c = a;\n    for _i in 0..10 {\n        // a = unsafe { a.__add(b) };\n        // b = unsafe { a.__mul(c) };\n        // c = unsafe { c.__mul(c) };\n        // RuntimeBigNum::evaluate_quadratic_expression(params, [[a]], [[false]], [[b]], [[false]], [c], [true]);\n        a = a.mul(a);\n        // b = b.mul(c);\n        // c = b.mul(a);\n    }\n}\n\n#[test]\nfn test_2048() {\n    main(1);\n}","path":"/Users/mike/git/use/src/main.nr"},"74":{"source":"use crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\nuse crate::constrained_ops::validate_quotient_in_range;\nuse crate::unconstrained_helpers::__barrett_reduction;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<\n    let N: u32,\n    let MOD_BITS: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field = mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n            - (borrow_flags[i - 1] * borrow_carry)) * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M]\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<\n    let N: u32,\n    let MOD_BITS: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained pub(crate) fn __compute_quadratic_expression<\n    let N: u32,\n    let MOD_BITS: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<\n    let N: u32,\n    let MOD_BITS: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size(1);\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size(1);\n        product_limbs[i] += \n            (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size(126); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/mike/git/noir-bignum/src/expressions.nr"},"75":{"source":"\n// Decomposes a single field into two 120 bit fields and a carry\nunconstrained pub fn split_120_bits(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let offsets: [Field; 17] = [\n        1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000, 0x10000000000000000, 0x1000000000000000000, 0x100000000000000000000, 0x10000000000000000000000, 0x1000000000000000000000000, 0x100000000000000000000000000, 0x10000000000000000000000000000, 0x1000000000000000000000000000000, 0x100000000000000000000000000000000\n    ];\n\n    for i in 0..15 {\n        low += (x_bytes[i] as Field) * offsets[i];\n        high += (x_bytes[i + 15] as Field) * offsets[i];\n    }\n    high += (x_bytes[30] as Field) * offsets[15];\n    high += (x_bytes[31] as Field) * offsets[16];\n    // TDOO: investigate why this is triggered in BigCurve crate? it shouldn't be?\n    //   assert(x_bytes[31] == 0);\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\nunconstrained pub fn split_60_bits(x: Field) -> (u64, u64) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: u64 = 0;\n    let mut high: u64 = 0;\n\n    let offsets: [u64; 8] = [1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000];\n    for i in 0..8 {\n        low += (x_bytes[i] as u64) * offsets[i];\n        high += (x_bytes[i + 8] as u64) * offsets[i];\n    }\n    let t1 = low >> 60;\n    let mask = ((1 as u64) << 60 as u8) - 1;\n    low = low & mask;\n    high = (high << 4) | t1;\n    (low, high)\n}\n\nunconstrained pub(crate) fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i]= lo;\n        inp[i + 1] +=  hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1]= lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/mike/git/noir-bignum/src/utils/split_bits.nr"},"76":{"source":"use crate::utils::split_bits;\nuse crate::utils::msb::get_msb64;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    limbs: [u64; N * NumSegments]\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe {\n                split_bits::split_60_bits(input[i])\n            };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    unconstrained pub fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    unconstrained pub fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    unconstrained fn into_field_array(x: U60Repr<N, NumSegments>) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i]= x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/mike/git/noir-bignum/src/utils/u60_representation.nr"},"112":{"source":"use dep::std;\nuse crate::utils::map::map;\n\nuse crate::params::BigNumParams;\nuse crate::constrained_ops::{\n    derive_from_seed, conditional_select, assert_is_not_equal, eq, validate_in_field, validate_in_range,\n    neg, add, sub, mul, div, udiv_mod, udiv, umod\n};\nuse crate::unconstrained_ops::{\n    __derive_from_seed, __eq, __is_zero, __neg, __add, __sub, __mul, __div, __udiv_mod, __invmod, __pow,\n    __batch_invert, __batch_invert_slice, __tonelli_shanks_sqrt\n};\nuse crate::expressions::{__compute_quadratic_expression, evaluate_quadratic_expression};\nuse crate::serialization::{from_be_bytes, to_le_bytes};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    limbs: [Field; N],\n    params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32> {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(params: BigNumParams<N, MOD_BITS>, seed: [u8; SeedBytes]) -> Self;\n    fn __derive_from_seed<let SeedBytes: u32>(params: BigNumParams<N, MOD_BITS>, seed: [u8; SeedBytes]) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool { lhs == rhs }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn neg(self) -> Self;\n    fn add(lhs: Self, rhs: Self) -> Self { lhs + rhs }\n    fn sub(lhs: Self, rhs: Self) -> Self { lhs - rhs }\n    fn mul(lhs: Self, rhs: Self) -> Self { lhs * rhs }\n    fn div(lhs: Self, rhs: Self) -> Self { lhs / rhs }\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(params: BigNumParams<N, MOD_BITS>, seed: [u8; SeedBytes]) -> Self {\n        let limbs = unsafe {\n            derive_from_seed::<_, MOD_BITS, _>(params, seed)\n        };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __derive_from_seed<let SeedBytes: u32>(params: BigNumParams<N, MOD_BITS>, seed: [u8; SeedBytes]) -> Self {\n        let limbs = unsafe {\n            __derive_from_seed::<_, MOD_BITS, _>(params, seed)\n        };\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __neg(params, self.limbs)\n        };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __add(params, self.limbs, other.limbs)\n        };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __sub(params, self.limbs, other.limbs)\n        };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __mul::<_, MOD_BITS>(params, self.limbs, other.limbs)\n        };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs)\n        };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        let (q, r) = unsafe {\n            __udiv_mod(self.limbs, divisor.limbs)\n        };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe {\n            __invmod::<_, MOD_BITS>(params, self.limbs)\n        };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        let limbs = unsafe {\n            __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs)\n        };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = unsafe {\n            __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn)))\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = unsafe {\n            let inv_slice = __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe {\n            __tonelli_shanks_sqrt(params, self.limbs)\n        };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/mike/git/noir-bignum/src/runtime_bignum.nr"},"113":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::unconstrained_helpers::{\n    __validate_in_field_compute_borrow_flags, __validate_gt_remainder, __neg_with_flags,\n    __add_with_flags, __sub_with_flags\n};\nuse crate::unconstrained_ops::{__mul, __div, __udiv_mod};\nuse crate::expressions::evaluate_quadratic_expression;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(params: P<N, MOD_BITS>, seed: [u8; SeedBytes]) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed = std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n    let num_hashes = (30 * N) / 32 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs = (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N-1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(lhs: [Field; N], rhs: [Field; N], predicate: bool) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1] ;\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, val: [Field; N]) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe {\n        __validate_in_field_compute_borrow_flags(params, val)\n    };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i-1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size(120);\n    }\n    let final_limb_bits = MOD_BITS - ((N - 1) * 120);\n    limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size(120);\n    }\n    // Note: replace magic number 6 with definition\n    let final_limb_bits = MOD_BITS - ((N - 1) * 120) + 6;\n    limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe {\n        __validate_gt_remainder(lhs, rhs)\n    };\n\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1 + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, val: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe {\n        __neg_with_flags(params, val)\n    };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) = unsafe {\n        __add_with_flags(params, lhs, rhs)\n    };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0] + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) = unsafe {\n        __sub_with_flags(params, lhs, rhs)\n    };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    let result = unsafe {\n        __mul::<_, MOD_BITS>(params, lhs, rhs)\n    };\n    evaluate_quadratic_expression(params, [[lhs]], [[false]], [[rhs]], [[false]], [result], [true]);\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse, \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\"\n    );\n    let result = unsafe {\n        __div::<_, MOD_BITS>(params, lhs, rhs)\n    };\n    evaluate_quadratic_expression(params, [[result]], [[false]], [[rhs]], [[false]], [lhs], [true]);\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N]\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe {\n        __udiv_mod(numerator, divisor)\n    };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false]\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, numerator: [Field; N], divisor: [Field; N]) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, numerator: [Field; N], divisor: [Field; N]) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/mike/git/noir-bignum/src/constrained_ops.nr"},"115":{"source":"use crate::utils::u60_representation::U60Repr;\nuse crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\nuse crate::unconstrained_helpers::{\n    __barrett_reduction , __primitive_root_log_size, __multiplicative_generator, __tonelli_shanks_sqrt_inner_loop_check\n};\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\nunconstrained pub(crate) fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\nunconstrained pub(crate) fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(params: P<N, MOD_BITS>, seed: [u8; SeedBytes]) -> [Field; N] {\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n    let compressed = std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let mut to_reduce: [Field; 2 * N] = [0; 2 * N];\n\n    let mut double_modulus_bits = MOD_BITS * 2;\n    let mut double_modulus_bytes = (double_modulus_bits) / 8 + (double_modulus_bits % 8 != 0) as u32;\n\n    let mut last_limb_bytes = double_modulus_bytes % 15;\n    if (last_limb_bytes == 0) {\n        last_limb_bytes = 15;\n    }\n    let mut last_limb_bits = double_modulus_bits % 8;\n    if (last_limb_bits == 0) {\n        last_limb_bits = 8;\n    }\n\n    for i in 0..(N - 1) {\n        let hash = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash : [u8; 30] = hash.to_le_bytes();\n        let mut lo: Field = 0;\n        let mut hi: Field = 0;\n        for j in 0..15 {\n            hi *= 256;\n            lo *= 256;\n\n            if (i < 2 * N - 2) {\n                lo += hash[j + 15] as Field;\n                hi += hash[j] as Field;\n            }\n        }\n        to_reduce[2 * i] = lo;\n        to_reduce[2 * i + 1] = hi;\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash : [u8; 30] = hash.to_le_bytes();\n        let mut hi: Field = 0;\n        for j in 0..(last_limb_bytes - 1) {\n            hi *= 256;\n            hi += hash[j] as Field;\n        }\n        hi *= 256;\n        let last_byte = hash[last_limb_bytes - 1];\n        let mask = (1 as u64 << (last_limb_bits) as u8) - 1;\n        let last_bits = last_byte as u64 & mask;\n        hi += last_bits as Field;\n        to_reduce[2 * N - 2] = hi;\n    }\n\n    let (_, remainder) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n    let result = remainder;\n    result\n}\n\nunconstrained pub(crate) fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\nunconstrained pub(crate) fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\nunconstrained pub(crate) fn __neg<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, limbs: [Field; N]) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\nunconstrained pub(crate) fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N]\n) -> [Field; N] {\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\nunconstrained pub(crate) fn __sub<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\nunconstrained pub(crate) fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n\n    (q, r)\n}\n\nunconstrained pub(crate) fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N]\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\nunconstrained pub(crate) fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N]\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\nunconstrained pub(crate) fn __udiv_mod<let N: u32, let MOD_BITS: u32>(numerator: [Field; N], divisor: [Field; N]) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\nunconstrained pub(crate) fn __invmod<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, val: [Field; N]) -> [Field; N] {\n    let one: [Field; N] = __one::<N>();\n    let one_u60: U60Repr<N, 2> = U60Repr::from(one);\n    let exp_u60 = params.modulus_u60.sub(one_u60.add(one_u60));\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\nunconstrained pub(crate) fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N]\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\nunconstrained pub(crate) fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(params: P<N, MOD_BITS>, x: [[Field; N]; M]) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\nunconstrained pub(crate) fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, x: [[Field; N]]) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\nunconstrained pub(crate) fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, input: [Field; N]) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = unsafe {\n        U60Repr::one()\n    };\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut found_root = false;\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one) == false) {} else {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                found_root = true;\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j { // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    let mut result = std::option::Option { _value: r, _is_some: found_root };\n    result\n}\n","path":"/Users/mike/git/noir-bignum/src/unconstrained_ops.nr"},"116":{"source":"use crate::utils::u60_representation::U60Repr;\nuse crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\nuse crate::unconstrained_ops::{__one, __eq, __neg, __add, __mul, __pow};\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\nunconstrained pub(crate) fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, val: [Field; N]) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\nunconstrained pub(crate) fn __validate_gt_remainder<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((b_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - b_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i/2] = carry as bool;\n            borrow_flags[i/2] = borrow as bool;\n        }\n    }\n\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\nunconstrained pub(crate) fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, val: [Field; N]) -> ([Field; N], [bool; N]) {\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        borrow = ((x_u60.limbs[i] + borrow_in) > params.modulus_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + params.modulus_u60.limbs[i] - x_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\nunconstrained pub(crate) fn __add_with_flags<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((subtrahend_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - subtrahend_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\nunconstrained pub(crate) fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if underflow {\n        addend_u60 = params.modulus_u60;\n    }\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((b_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - b_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i/2] = carry as bool;\n            borrow_flags[i/2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\nunconstrained pub(crate) fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>\n) -> ([Field; N], [Field; N]) {\n    let mut mulout: [Field; 3 * N]  = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 2);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n    let mut partial_quotient: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..2 * N {\n        partial_quotient[i] = partial_quotient_full[i];\n    }\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: [Field; 2 * N]  = [0; 2 * N];\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N]  = [0; 2 * N];\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus[i + j] += partial_quotient[i] * modulus[j];\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus[i + 1] += hi;\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    let x_u60 : U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\nunconstrained pub(crate) fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (!lsb_is_one) {\n            result += 1;\n            target.shr1();\n        } else {\n            break;\n        }\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N]\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = unsafe {\n            __add(params, target, one)\n        };\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(params, _target, p_minus_one_over_two);\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\nunconstrained pub(crate) fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(params, target, p_minus_one_over_two);\n    target\n}\n\nunconstrained pub(crate) fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(params: P<N, MOD_BITS>, t2m: [Field; N], i: u32) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/mike/git/noir-bignum/src/unconstrained_helpers.nr"}},"names":["main"],"brillig_names":["print_unconstrained","__derive_from_seed","__mul","__compute_quadratic_expression_with_borrow_flags"]}