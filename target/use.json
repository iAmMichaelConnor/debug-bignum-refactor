{"noir_version":"0.35.0+999071b80e61a37cb994a4e359eabbac27cd53f1","hash":128796926708635376,"abi":{"parameters":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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y33fM0/Lfd8zT8t93zNPy33fM0/Lfd8zTUu+7pk3aql+32PHxdTSD7Wku++xbuXxees1fNXygzLd7QmmbHqU6cw+pkznyTFlOuuMKdM5XEyZzohCynwVOJgyna3DlPXcF18FDqZsepT13BdfBQ6mrOe++HptMGU998XXa4Mp67kvvl4bTFnPffH12mDKeu6Lr6wGU9ZzX3xlNZiynPtKfGU1mLKc+0p8ZTWYspz7SofpUZZzX4mvgQZTlnNfia+BBlPWc198DTSYsp774quVwZT13BdfrQymrOe++GplMGU998XXFYMp67kvvq4YTFnPffF1xWDKeu6LrwAGU9ZzX3wFMJiynvviK4DBlPXcF1+rC6as5774Wl0wZT33xdfqginruS++qhZMWc998VW1YMp67ouvfwVT1nNffP0rmLKe++IrVcGU9dwXX6kKpqznvviaUjBlPffF15SCKeu5rwXqT6ZT1nNffG0pmLKe++LrHsGU9dwXX5MHpqznvvh6MTBlPffF1zKBKeu5L77OBkxZz33xNSBgynrui69PAFPWc1986fyYsp770su6T3pZ90kv6z7pZd0nvaz7pJd1n/Sy7pNe1n3Sy7pPeln3SS/rPull3Se9rPukl3Wf9LLuk17WfdLLuk96WfdJL+s+6WXdJ72s+6SXdZ/0su6TXtZ90su6T3pZ90kv6z7pZd2bXta96WXdm17Wvell3dthepTl3JfpZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17Wvell3Zte1r3pZd2bXta96WXdm17WfdbLus96WfdZL+s+62Xd58P0KMu5r6yXdZ/1su6zXtZ91su6z3pZ91kv6z7rZd1nvaz7rJd1n/Wy7rNe1n3Wy7rPeln3WS/rPutl3We9rPusl3Wf9bLus17WfdbLus96WfdZL+s+62XdZ72s+6yXdZ/1su6zXtZ91su6z3pZ91kv6z7rZd1nvaz7rJd1n/Wy7rNe1n3Wy7rPeln3WS/rPutl3We9rPusl3Wf9bLus17WfdbLus96WfdZL+s+62XdZ72s+6yXdZ/1su6zXtZ91su6z3pZ91kv6z7rZd1nvaz7rJd1n/Wy7rNe1n3Wy7rPeln3WS/rPutl3We9rPusl3Wf9bLus17WfdbLus96WfdZL+s+62XdZ72s+6yXdZ/1su6zXtZ91su6z3pZ91kv6z7rZd1nvaz7rJd1n/Wy7rNe1n3Wy7rPeln3WS/rPutl3We9rPusl3Wf9bLuM1/WfSm1Pj5faohfKd8/no8H9pw+1Tkpf6hDZ9RKC+FSp1n5kTp0nm6qOnT2b6I6hS+Xf6o6dKZyqjp0/nOqOnRWdao6ttUZqENngKeqw+eVZ6qzvfJIne2VR+psrzxQh69FYao62yuP1NleeaTO9sojdWyrM1Bne+WROtsrj9TZXnmkzvbKI3W2Vx6ow9d5MVWd7ZVH6myvPFJne+WROrbVGaizvfJIne2VR+psrzxSZ3vlkTrbKw/U4WsoaSE+4Jx/5/ZVnQ/KdAa4nafBRTke9qMTgs4A4xOCztViyqZHmc5/Tr3s6fwnPiHoTCWmTOcUMWU6+zfzsuerSIEnBF9FCqas5+n4KlIwZdsr3WClI7R/6ITQ83R8bSqYsp6n42tTmbnS8RWvwBOCr3gFU9bzdHzFK5iy6VHe+3SjxV3P0/F1tGDKep6Or6MFUubraMGU92+vg8Wdr84FnxB6no6vzgVT1tt846tzwZT1jBpfncvUeabn6fiaXzBlvc03vuYXTFnPqPE1v2DKe/NtMM/4SmLwCaHn6fhKYjBlPaPGVxKDKesZNb6SGEyZ0KjNG+F8fTL4hNDbfOPrk8GU9YwaX58Mpqxn1Pj6ZDDl/SvpYITzVc/gE0Jv842vegZT1jNqfNUzmLKeUeMricGU5Yxa5atzmehaKl+dCz4h5Ixa5StewZRNj7KcUat8vSeYspxRq3wNJZjyfpd04Fr4akfgCcHXJYIp6xk1vtYPTNn0KOsZNb7SDUxZz6jx1WNgytuoDYwaX+cFPCH4iiwwZT2jxlc5gSmbHmU9o8bX+IAp6xk1vm4GTHkbtYFR0ytcqIyFC4iynlHTa1Goei0KlbFFAVHWM2p61QhVrxqhMlYjAMqMfQfzvKleNULVq0aoetUIlbEaAVHWM2p6fQdVr++g6vUdVMa+A0BZr8SgMpYYzPOmen0HVa/voOr1HVTGvgNEWc+o6ZUYVL0Sg6pXYlD1SgwqY4kBoqznvhibCebZcb0Sg6pXYlD1SgyqXolBZSwxQJT1jJpeM0HVayaoes0EVa+ZoDI2E8zzpowlBuiE0DNqes0EVa+ZoOo1E1S9ZoKq10xQ9ZoJKmMzAaJs26j9s1HTayaoes0EVa+ZoOo1E1S9ZoKq10xQGZsJEGU9o6ZXN1AZ6wbmGTW9ZoKq10xQ9ZoJql4zQdVrJmiMzQSIspxRa3p1A42xbmCaa2mH6Z0Qckat6TUTNL1mgqbXTNAYmwkAZb26gaZXN9AY6wbmuRa9ZoKm10zQ9JoJml4zQdNrJmh6zQSNsZkAUGasG5g3wvWaCZpeM0HTayZoes0ETa+ZoOk1EzS9ZoLG2EwwcYTreTq9ZoKm10zQ9JoJml4zQdNrJmiMzQTz5pleiUHTKzFoeiUGTa/EoDGWGCDKekaNsZlg3jzTKzFoeiUGTa/EoOmVGDS9EoPGWGIwcXHX83R6fQeNse8AUdbbfNMrMWiMJQbzFne9voOm13fQ9PoOml7fQWPsO5i30ulVIzS9aoSmV43QGKsREGXbK91gpdPzdHrVCE2vGqExViNMvOz19un0WhSaXotCY2xRmHfZ6xUuNMbCBUR5P083ugb47J/l41LHar+fEP7t35fPHznG3yh/cKDzczGm66SOVo77PxudSYulXmdqrAFdx6FeF3I8Evjy8VXPV83wRi3pbOUbtaTzq2/Uks7dvlFL21pO05LOj79RSzr3/kYt6XaF36gl3+3J+7Tc9z3TtORrOnmjlvu+Z56W+75nnpb7vmeelra1nKblvu+Zp6X6fY8dF1NLP9SS7r7HupXH563X8FXLD8p0tyeYMt1dBKLc+dpyMGU6T44p01lnTJnO4WLKpkeZzi9iynS2DlOWc1+drwIHU9ZzX3wVOJiynvviq8DBlPXcF1+vDaas5774em0wZT33xddrgynruS++XhtMWc998ZXVYMp67ouvrAZT1nNffGU1mLKe++Irq8GU9dwXXwMNpqznvvgaaDBlPffF10CDKeu5L75aGUxZz33x1cpgynrui69WBlPWc198tTKYsp774uuKwZT13BdfVwymrOe++LpiMGU998VXAIMp67kvvgIYTFnPffEVwGDKeu6Lr9UFU9ZzX3ytLpiynvviq2rBlPXcF19VC6as5774qlowZT33xde/ginruS++/hVMWc998ZWqYMp67ouvVAVT1nNffE0pmLKe++KrP8GU9dwXX1sKpqznvvhKTTBlPffFVxGCKeu5L77CDUxZz33x1Vdgynrui68MAlPWc1981QqYsp774isqwJT13Bdf7D+mrOe++EL0MWU996WXdd/lsu7jIZd1f1JWc18nZTX3dVJWc18nZdOjrOa+Tspq7uukrOa+Tspq7uukrOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT4R67ksu6/5EqOe+5LLuT4R67ksu6/5EqOe+5LLuT4R67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8p67ksu6/6krOe+5LLuT8py7ivoZd0Hvaz7oJd1H/Sy7sNhepTl3FfQy7oPeln3QS/rPuhl3Qe9rPugl3Uf9LLug17WfdDLug96WfdBL+s+6GXdB72s+6CXdR/0su6DXtZ90Mu6D3pZ90Ev6z7oZd0Hvaz7oJd1H/Sy7oNe1n3Qy7oPeln3QS/rPuhl3Qe9rPugl3Uf9LLug17WfdDLug96WfdBL+s+6GXdB72s+6CXdR/0su6DXtZ90Mu6D3pZ90Ev6z7oZd0Hvaz7oJd1H/Sy7oNe1n3Qy7oPeln3QS/rPuhl3Qe9rPugl3Uf9LLug17WfdDLug96WfdBL+s+6GXdB72s+6CXdR/0su6DXtZ90Mu6D3pZ90Ev6z7oZd0Hvaz7oJd1H/Sy7oNe1n3Qy7oPeln3QS/rPuhl3Qe9rPugl3Uf9LLug17WfdDLug96WfdBL+s+6GXdB72s+6CXdR/0su6DXtZ90Mu6D3pZ90Ev6z7oZd0Hvaz7oJd1H/Wy7qNe1n3Uy7qPeln38TA9ynLuK+pl3Ue9rPuol3Uf9bLuo17WfdTLuo96WfdRL+s+6mXdR72s+6iXdR/1su6jXtZ91Mu6j3pZ95Ev676UWh+fLzXEr5TvH8/HA3tOn+qclD/UoTNqpYVwqdOs/EgdOk83VR3b6gzUoXOKU9WhM5VT1aHzn1PVobOqU9Whc7Uz1eGrG5iqDp9XnqnO9sojdbZXHqljW52BOtsrj9TZXnmkzvbKI3W2Vx6ps73yQB2+coip6myvPFJne+WROtsrj9Sxrc5Ane2VR+psrzxSZ3vlkTrbK4/U2V55oA5flcdUdbZXHqmzvfJIne2VR+rYVmegDp1XbiE+4Jx/5/ZVnQ/KdAa4nafBRTke9qMTgs4A4xOCztViynRWFVLmKzOZednz9Z7gE4LOVGLKdE4RU7Z92Q8uez37x1eRginreTq+ihRMmdDTzVvp+NpU4AnB16aCKet5Or42FUzZ9ko3WOn0PB1f8QqmrOfp+IpXMGW9fTq+4pWZiztfRws+IfQ8HV9HC6ZsepT1jBpfR8vUxV3P0/HVuWDKep6Or84FU9Yzanx1LpgyoVGbN8/4ml/wCaHn6fiaXzBlPaPG1/yCKcsZtcTX/DJxniW+khh8Qsh5usRXEoMpmx5lOaOW+EpiMGU5o5b4SmKmjnA9T8fXJ4Mp6xk1vj4ZTFnPqPH1yWDKekaNr09m5gjnq57BJ4Tc5lviq56BlPmqZzBlPaPG1yeDKesZNb7mF0yZ0KjNcy18dS74hNAzanzFK5iynlHjq0jBlPWMGl+ZCaasZ9T4akdmuha+2hF8QugZNb6CEExZz6jxVXlAynz9HJiynlHja9LAlPWMGl/nxUyjxtd5gU8IPaPG106BKesZNb4eCUiZrxwCU9Yzanw1DpiynlHjK1yYadT0ChcSY+ECoqxn1PRaFJJei0JibFFAlPWMml41QtKrRkiM1QiI8n5GbeBN9aoRkl41QtKrRkiM1QiAsl7fQdLrO0h6fQdJr+8gMfYdIMp622SMJQbzvKle30HS6ztIen0HibHvAFHWM2p6JQZJr8Qg6ZUYJL0Sg8RYYoAo67kvxmaCeXZcr8Qg6ZUYJL0Sg6RXYpAYSwwQZdOjrGfU9JoJkl4zQdJrJkiMzQTTvKkxlhiMTwjTayYwvWYC02smsMP0KMsZNdNrJjC9ZgJjbCZAlLdRGxg1vWYC02smML1mAtNrJjC9ZgLTayYwxmYCRFnPqOnVDRhj3cA8o6bXTGB6zQSm10xges0EptdMYIzNBIiynlHTqxswxrqBia5F7hk102smML1mAtNrJjC9ZgJjbCZAlPWMml7dgDHWDcxzLXrNBKbXTGB6zQSm10xges0EptdMYIzNBIjyzlEbjHC9ZgLTayYwvWYC02smML1mAtNrJjC9ZgJjbCaYN8IZSwzQCaG3+abXTGB6zQSm10xges0ExthMMG+e6ZUYmF6JgemVGJheiYExlhggynpGjbGZYOI80/N0eiUGpldiYHolBqZXYmCMJQbzFne9vgPT6zswxr4DRFlv802vxMAYSwzmLe56fQem13dgen0Hptd3YIx9BxNXOj1Pp1eNYHrVCMZYjYAob083WOn0qhFMrxrB9KoRjLEaYeJlb3onhJ6n02tRMMYWhYmXvZ79YyxcGFPOjC0K066BTFi4YPm41Dn3sO8nhH/79+XzR47xN8ofHOj8XIzpOqn/egj2/s9mdJRLvc7UWAO6jkO9LuR4JPDl4Kqnc39v1JLOVr5RSzq/+kYt6dztG7Wks83v05KvLOONWtK59zdqSbcr/EYt+W5P3qelbS2nabnve+Zpue975mm573vmabnve+Zpue97pmnJ1z3zRi3V73vsuJha+qGWdPc91q08Pn/+BB6+avlBme72BFM2Pcp0Zh9TpvPkmDKddcaU6RwupkxnRCFlvgocTJnO1mHKeu6LrwIHUzY9ynrui68CB1PWc198vTaYsp774uu1wZT13Bdfrw2mrOe++HptMGU998VXVoMp67kvvrIaTFnPffGV1WDKeu6Lr6wGU9ZzX3wNNJiynvvia6DBlPXcF18DDaas5774GmgwZT33xVcrgynruS++WhlMWc998dXKYMp67ouvKwZT1nNffF0xmLKe++LrisGU9dwXXwEMpqznvvgKYDBlPffFVwCDKeu5L75WF0xZz33xtbpgynrui6/VBVPWc198VS2Ysp774qtqwZT13Bdf/wqmrOe++PpXMGU998VXqoIp67kvvlIVTFnPffE1pWDKcu6r8DWlYMpy7qssUH8ynbKc+yqH6VGWc1+Fr3sEU5ZzX4WvyQNT1nNffL0YmLKe++JrmcCU9dwXX2cDpqznvvgaEDBlPffF1yeAKeu5L750fkxZz33pZd0Xvaz7opd1X/Sy7ote1n3Ry7oveln3RS/rvuhl3Re9rPuil3Vf9LLui17WfdHLui96WfdFL+u+6GXdF72s+6KXdV/0su6LXtZ90cu6L3pZ90Uv677oZd0Xvaz7opd1X/Sy7ote1n3Ry7oveln3RS/rvuhl3Re9rPuil3Vf9LLui17WfdHLui96WfdFL+u+6GXdF72s+6KXdV/0su6LXtZ90cu6L3pZ90Uv677oZd0Xvaz7opd1X/Sy7ote1n3Ry7oveln3RS/rvuhl3Re9rPuil3Vf9LLui17WfdHLui96WfdFL+u+6GXdF72s+6KXdV/0su6LXtZ90cu6L3pZ90Uv677oZd0Xvaz7opd1X/Sy7ote1n3Ry7qveln3VS/rvupl3Ve9rPt6mB5lOfdV9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvupl3Ve9rPuql3Vf9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvupl3Ve9rPuql3Vf9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvupl3Ve9rPuql3Vf9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvupl3Te9rPuml3Xf9LLum17WfTtMj7Kc+2p6WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Te9rPuml3Xf9LLum17WfdPLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pvfFn3pdT6+HypIX6lfP94Ph7Yc/pU56T8oQ6dUSsthEud81//R+rQebqp6tDZv5nq8OXyT1WHzlROVYfOf05Vh86qTlXHtjoDdegM8FR1+LzyTHW2Vx6ps73ySJ3tlQfq8LUoTFVne+WROtsrj9TZXnmkjm11BupsrzxSZ3vlkTrbK4/U2V55pM72ygN1+DovpqqzvfJIne2VR+psrzxSx7Y6A3W2Vx6ps73ySJ3tlUfqbK88Umd75YE6fA0lLcQHnPPv3L6q80GZzgC38zS4KMfDfnRC0BlgfELQuVpM2fQo0/nPqZc9nf/EJwSdqcSU6Zwipkxn/2Ze9nwVKfCE4KtIwZT1PB1fRQqmbHulG6x0hPYPnRB6no6vTQVT1vN0fG0qE1e6zle8gk6Izle8ginLebrOV7yCKZse5b1PN1rc5Txd5+towZTlPF3n62iBlPk6WjDl/dvrYHHnq3PBJ4Sep+Orc8GU5TbfOl+dC6asZ9T46lymzjM9T8fX/IIp622+8TW/YMp6Ro2v+QVT3ptvg3nGVxKDTwg9T8dXEoMp6xk1vpIYTFnPqPGVxGDKhEZt3gjn65PBJ4Te5htfnwymrGfU+PpkMGU9o8bXJ4Mp719JByOcr3oGnxB6m2981TOYsp5R46uewZT1jBpfSQymrGfU+OpcZroWvjoXfELoGTW+4hVM2fQo6xk1vt4TTFnPqPE1lGDK+13SgWvhqx2BJwRflwimrGfU+Fo/MGXTo6xn1PhKNzBlPaPGV4+BKW+jNjBqfJ0X8ITgK7LAlPWMGl/lBKZsepT1jBpf4wOmrGfU+LoZMOVt1AZGTa9woTMWLiDKekZNr0Wh67UodMYWBURZz6jpVSN0vWqEzliNACgz9h3M86Z61Qhdrxqh61UjdMZqBERZz6jp9R10vb6Drtd30Bn7DoaU0yFXYnBS3m99/qM3PdVRM2onZTWjdlI2PcpqRu2krGbUTspqRu2krGbUTsp6Rk2uxOCkrLZNdlLWc1+MzQTz7LhcicFJWc+oyZUYnJT1jBpjiQGirGfU5JoJTsp6Rk2umeCkrLdNxthMMM+bMpYYoBNCz6jJNROclPWMmlwzQTrkmglOynpGTa6Z4KSsZ9QY6wbmGTW5ZoKTsp5Rk2smOCnrGTW5ZoJ0yDUTnJT1jJpc3cBJWc+oMdYNzDNqcs0EJ2U9oybXTHBS1jNqcs0E6WBsJkCU9YyaXN3ASXk/ozZwLXLNBCdlPaMm10xwUtYzanLNBCdlPaMmVzdwUtYzaox1A/Nci1wzwUnZ9CjrGTW5ZoKTsp5Rk2smOCnrGTXGuoF5I1yumeCkrLf5JtdMcFI2Pcp6Rk2umeCkrGfUGJsJJo5wPU8n10xwUtYzanLNBCdlPaMm10xwUiY0avPmmVyJwUlZz9PJlRiclPWMGmOJAaKsZ9QYmwnmzTO5EoOTsulR1tt8kysxOCnrGTXGEoOJi7ucpwt6fQeBse8AUZbbfAt6JQbhsL24/+PiHvT6DoJe30HQ6zsIen0HgbHvYN5Kp1eNEPSqEYJeNUJgrEZAlG2vdIOVTs/T6VUjBL1qhMBYjTDxstfbp9NrUQh6LQqBsUVh3mWvV7gQGAsXEOX9PN3oGuCzf5aPSx2r/X5C+Ld/Xz5/5Bh/o/zBgc7PxZiukzpaOe7/bHQmLZZ6namxBnQdh3pdyPFI4MvHVz1fNcMbtaSzlW/Uks6vvlFLOnf7Ri1tazlNSzo//kYt6dz7G7Wk2xV+o5Z8tyfv03Lf90zTkq/p5I1a7vueeVru+555Wu77nnla2tZympb7vmeelur3PXZcTC39UEu6+x7rVh6ft17DVy0/KNPdnmDKdHcRkDJfWw6mTOfJMWU664wp0zlcTNn0KNP5RUyZztZhynrui68CB1PWc198FTiYsp774qvAwZT13Bdfrw2mrOe++HptMGU998XXa4Mp67kvvl4bTFnPffGV1WDKeu6Lr6wGU9ZzX3xlNZiynvviK6vBlPXcF18DDaas5774GmgwZT33xddAgynruS++WhlMWc998dXKYMp67ouvVgZT1nNffLUymLKe++LrisGU9dwXX1cMpqznvvi6YjBlOfcV+QpgMGU59xX5CmAwZTn3FQ/ToyznviJfqwumLOe+Il+rC6as5774qlowZT33xVfVginruS++qhZMWc998fWvYMp67ouvfwVT1nNffKUqmLKe++IrVcGU9dwXX1MKpqznvvjqTzBlPffF15aCKeu5L75SE0xZz33xVYRgynrui69wA1PWc1989RWYsp774iuDwJT13BdftQKmrOe++IoKMGU998UX+48p67kvvhB9TFnPfell3Ue9rPuol3Uf9bLuo17WfdTLuo96WfdRL+s+6mXdR72s+6iXdR/1su6jXtZ91Mu6j3pZ91Ev6z7qZd1Hvaz7qJd1H/Wy7qNe1n3Uy7qPeln3US/rPupl3Ue9rPuol3Uf9bLuo17WfdTLuo96WfdRL+s+6mXdR72s+6iXdR/1su6jXtZ91Mu6j3pZ91Ev6z7qZd1Hvaz7qJd1H/Wy7qNe1n3Uy7qPeln3US/rPupl3Ue9rPuol3Uf9bLuk17WfdLLuk96WfdJL+s+HaZHWc59Jb2s+6SXdZ/0su6TXtZ90su6T3pZ90kv6z7pZd0nvaz7pJd1n/Sy7pNe1n3Sy7pPeln3SS/rPull3Se9rPukl3Wf9LLuk17WfdLLuk96WfdJL+s+6WXdJ72s+6SXdZ/0su6TXtZ90su6T3pZ90kv6z7pZd0nvaz7pJd1n/Sy7pNe1n3Sy7pPeln3SS/rPull3Se9rPukl3Wf9LLuk17WfdLLuk96WfdJL+s+6WXdJ72s+6SXdZ/0su6TXtZ90su6T3pZ90kv6z7pZd0nvaz7pJd1n/Sy7pNe1n3Sy7pPeln3SS/rPull3Se9rPukl3Wf9LLuk17WfdLLuk96WfdJL+s+6WXdJ72s+6SXdZ/0su6TXtZ90su6T3pZ90kv6z7pZd0nvaz7pJd1n/Sy7pNe1n3Sy7pPeln3SS/rPull3Se9rPukl3Wf9LLuk17WfdLLuk96Wfeml3Vveln3ppd1b3pZ93aYHmU592V6Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ96aXdW96Wfeml3Vveln3ppd1b3pZ98aXdV9KrY/PlxriV8r3j+fjgT2nT3VOyh/q0Bm10kK41GlWfqQOnaebqo5tdQbq0DnFqerQmcqp6tD5z6nq0FnVqerQudqZ6vDVDUxVh88rz1Rne+WROtsrj9Sxrc5Ane2VR+psrzxSZ3vlkTrbK4/U2V55oA5fOcRUdbZXHqmzvfJIne2VR+rYVmegzvbKI3W2Vx6ps73ySJ3tlUfqbK/8z+pkviqPqepsrzxSZ3vlkTrbK4/Usa3OQB06r9xCfMA5/87tqzoflOkMcDtPg4tyPOxHJwSdAcYnBJ2rxZTprCqkzFdmMvOy5+s9wScEnanElOmcIqZs+7IfXPZ69o+vIgVT1vN0fBUpmDKhp5u30vG1qcATgq9NBVPW83R8bSqYsu2VbrDS6Xk6vuIVTFnP0/EVr2DKevt0fMUrMxd3vo4WfELoeTq+jhZM2fQo6xk1vo6WqYu7nqfjq3PBlPU8HV+dC6asZ9T46lwwZUKjNm+e8TW/4BNCz9PxNb9gynpGja/5BVPWM2p8zS8z5xlfSQw+IfQ8HV9JDKZsepT1jBpfSQymrGfU+Epipo5wPU/H1yeDKesZNb4+GUxZz6jx9clgynpGja9PZuYI56uewSeE3uYbX/UMpMxXPYMp6xk1vj4ZTFnPqPE1v2DKhEZtnmvhq3PBJ4SeUeMrXsGU9YwaX0UKpqxn1PjKTDBlPaPGVzsy07Xw1Y7gE0LPqPEVhGDKekaNr8oDUubr58CU9YwaX5MGpqxn1Pg6L2YaNb7OC3xC6Bk1vnYKTFnPqPH1SCDKha8cAlOWM2qFr8YBU5YzauWwbdT+0agVvcKFwli4gCjLGbWi16JQ9FoUCmOLAqKsZ9T0qhGKXjVCYaxGQJT3M2oDb6pXjVD0qhGKXjVCYaxGAJT1+g6KXt9B0es7KHp9B4Wx7wBR1tsmYywxmOdN9foOil7fQdHrOyiMfQeIsp5R0ysxKHolBkWvxKDolRgUxhIDRFnPfTE2E8yz43olBkWvxKDolRgUvRKDwlhigCibHmU9o6bXTFD0mgmKXjNBYWwmmOdNGUsMwAmh10xQ9JoJil4zQdFrJih6zQRFr5mg6DUTFMZmAkR5G7WBUdNrJih6zQRFr5mg6DUTFL1mgqLXTFAYmwkQZT2jplc3UBjrBuYZNb1mgqLXTFD0mgmKXjNB0WsmKIzNBIiynlHTqxsojHUDE12L3jNqes0ERa+ZoOg1ExS9ZoLC2EyAKOsZNb26gcJYNzDPteg1ExS9ZoKi10xQ9JoJil4zQdFrJiiMzQSI8s5RG4xwvWaCotdMUPSaCYpeM0HVayaoes0EVa+ZoDI2E0wb4fUwvRNCbvOt6jUTVL1mgqrXTFD1mgkqYzPBvHmmV2JQ9UoMql6JQdUrMaiMJQaIsp5RY2wmmDjP9DydXolB1SsxqHolBlWvxKAylhjMW9z1+g6qXt9BZew7QJT1Nt/0SgwqY4nBvMVdr++g6vUdVL2+g6rXd1AZ+w4mrnR6nk6vGqHqVSNUxmoERHl7usFKp1eNUPWqEapeNUJlrEaYeNmb3gmh5+n0WhQqY4vCxMtez/4xFi4AyowtCvOuAcLCBcvHpY7Vfj8h/Nu/L58/coy/Uf7gQOfnYkzXSR2tHPd/NqOjXOp1psYa0HUc6nUhxyOBLwdXPZ37e6OWdLbyjVrS+dU3aknnbt+oJZ1tfp+WfGUZb9SSzr2/UUu6XeE3asl3e/I+LW1rOU3Lfd8zT8t93zNPy33fM0/Lfd8zT8t93zNNS77umTdqqX7fY8fF1NIPtaS777Fu5fF56zV81fKDMt3tCaZsepTpzD6mTOfJMWU664wp0zlcTJnOiELKfBU4mDKdrcOU9dwXXwUOpmx6lPXcF18FDqas5774em0wZT33xddrgynruS++XhtMWc998fXaYMp67ouvrAZT1nNffGU1mLKc+2p8ZTWYspz7anxlNZiynPtqh+lRlnNfja+BBlOWc1+Nr4EGU9ZzX3wNNJiynvviq5XBlPXcF1+tDKas5774amUwZT33xdcVgynruS++rhhMWc998XXFYMp67ouvAAZT1nNffAUwmLKe++IrgMGU9dwXX6sLpqznvvhaXTBlPffF1+qCKeu5L76qFkxZz33xVbVgynrui69/BVPWc198/SuYsp774itVwZT13BdfqQqmrOe++JpSMGU998XXlIIp67mvBepPplPWc198bSmYsp774usewZT13BdfkwemrOe++HoxMGU998XXMoEp67kvvs4GTFnPffE1IGDKeu6Lr08AU9ZzX3zp/JiynvvSy7pveln3TS/rvull3Te9rPuml3Xf9LLum17WfdPLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Xe9rPuul3Xf9bLuu17WfT9Mj7Kc++p6WfddL+u+62Xdd72s+66Xdd/1su67XtZ918u673pZ910v677rZd13vaz7rpd13/Wy7rte1n3Xy7rveln3XS/rvutl3Xe9rPuul3Xf9bLuu17WfdfLuu96WfddL+u+62Xdd72s+66Xdd/1su67XtZ918u673pZ910v677rZd13vaz7rpd13/Wy7rte1n3Xy7rveln3XS/rvutl3Xe9rPuul3Xf9bLuu17WfdfLuu96WfddL+u+62Xdd72s+66Xdd/1su67XtZ918u673pZ910v677rZd13vaz7rpd13/Wy7rte1n3Xy7rveln3XS/rvutl3Xe9rPuul3Xf9bLuu17WfdfLuu96WfddL+u+62Xdd72s+66Xdd/1su67XtZ918u673pZ910v677rZd13vaz7rpd13/Wy7rte1n3Xy7rveln3XS/rvutl3Xe9rPuul3Xf5bLu7ZDLuj8pq7mvk7Ka+zopq7mvk7LpUVZzXydlNfd1UlZzXydlNfd1UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPfcll3V/UtZzX3JZ9ydlPffFl3VfSq2Pz5ca4lfK94/n44E9p091Tsof6tAZtdJCuNRpVn6kDp2nm6oOnf2bqE7gy+Wfqg6dqZyqDp3/nKoOnVWdqo5tdQbq0BngqerweeWZ6myvPFJne+WROtsrD9Tha1GYqs72yiN1tlceqbO98kgd2+oM1NleeaTO9sojdbZXHqmzvfJIne2VB+rwdV5MVWd75ZE62yuP1NleeaSObXUG6myvPFJne+WROtsrj9TZXnmkzvbKA3X4GkraOWken28ht6/qfFCmM8DtPA0uyvGwH50QdAYYnxB0rhZTNj3KdP5z6mVP5z/xCUFnKjFlOqeIKdPZv5mXPV9FCjwh+CpSMGU9T8dX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VoMp67kvvrIaTFnPffE10GDKeu6Lr4EGU9ZzX3wNNJiynvviq5XBlPXcF1+tDKas5774amUwZT33xVcrgynruS++rhhMWc998XXFYMp67ouvKwZTlnNfla8ABlOWc1+VrwAGU5ZzX/UwPcpy7qvytbpgynLuq/K1umDKeu6Lr6oFU9ZzX3xVLZiynvviq2rBlPXcF1//Cqas5774+lcwZT33xVeqginruS++UhVMWc998TWlYMp67ouv/gRT1nNffG0pmLKe++IrNcGU9dwXX0UIpqznvvgKNzBlPffFV1+BKeu5L74yCExZz33xVStgynrui6+oAFPWc198sf+Ysp774gvRx5T13Jde1n3Vy7qveln3VS/rvupl3Ve9rPuql3Vf9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvupl3Ve9rPuql3Vf9bLuq17WfdXLuq96WfdVL+u+6mXdV72s+6qXdV/1su6rXtZ91cu6r3pZ91Uv677qZd1Xvaz7qpd1X/Wy7qte1n3Vy7qveln3VS/rvull3Te9rPuml3Xf9LLu22F6lOXcV9PLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Te9rPuml3Xf9LLum17WfdPLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Te9rPuml3Xf9LLum17WfdPLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Te9rPuml3Xf9LLum17WfdPLum96WfdNL+u+6WXdN72s+6aXdd/0su6bXtZ908u6b3pZ900v677pZd03vaz7ppd13/Sy7pte1n3Ty7pveln3TS/rvull3Te9rPuml3Xf9bLuu17WfdfLuu96Wff9MD3Kcu6r62Xdd72s+66Xdd/1su67XtZ918u673pZ910v677rZd13vaz7rpd13/Wy7rte1n3Xy7rveln3XS/rvutl3Xe9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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"35":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n","path":"std/hash/sha256.nr"},"70":{"source":"use dep::bignum::{\n    bignum::BigNum, runtime_bignum::RuntimeBigNum, fields::{bn254Fq::BN254_Fq_Params, U256::U256Params},\n    params::{BigNumParams, BigNumParamsGetter},\n    utils::u60_representation::U60Repr\n};\n\n//**************************************************************************\n//**************************************************************************\n//**************************************************************************\n// THIS FILE IS ONLY COMPATIBLE WITH DEP:\n// bignum = {tag = \"mc/refactor\", git = \"https://github.com/noir-lang/noir-bignum\"}\n//**************************************************************************\n//**************************************************************************\n//**************************************************************************\n\nstruct Test2048Params{}\n\n// See https://github.com/noir-lang/noir/issues/6172\n#[test]\nfn silence_warning() {\n    let _  = Test2048Params {};\n}\n\nimpl BigNumParamsGetter<18> for Test2048Params {\n    fn get_params() -> BigNumParams<18> {\n        let has_multiplicative_inverse = false;\n        let modulus_bits_getter = || 2048;\n        let modulus: [Field; 18] = [\n            0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n            0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n            0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n            0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n            0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n            0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n            0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n            0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n            0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n            0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n            0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n            0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n            0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n            0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n            0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n            0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n            0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n            0x00000000000000000000000000000000000000000000000000000000000000b8\n        ];\n        let redc_param: [Field; 18] = [\n            0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n            0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n            0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n            0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n            0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n            0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n            0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n            0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n            0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n            0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n            0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n            0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n            0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n            0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n            0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n            0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n            0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n            0x0000000000000000000000000000000000000000000000000000000000000162\n        ];\n        BigNumParams::new(\n            has_multiplicative_inverse,\n            modulus_bits_getter,\n            modulus,\n            redc_param\n        )\n    }\n}\n\ntype BN254_Fq = BigNum<3, BN254_Fq_Params>;\ntype U256_Fq = BigNum<3, BN254_Fq_Params>;\n\n// fn main(x: u8) {\n//     let _a: BN254_Fq = BigNum::__derive_from_seed([x,2,3,4]);\n//     let mut a = _a;\n//     // let mut b = a;\n//     // let mut c = a;\n//     for _i in 0..10 {\n//         // a = unsafe { a.__add(b) };\n//         // b = unsafe { a.__mul(c) };\n//         // c = unsafe { c.__mul(c) };\n//         // BigNum::evaluate_quadratic_expression([[a]], [[false]], [[b]], [[false]], [c], [true]);\n//         a = a.mul(a);\n//         // b = b.mul(c);\n//         // c = b.mul(a);\n//     }\n// }\n\n// #[test]\n// fn test_bn254_fq() {\n//     // let a: BN254_Fq = BigNum::__derive_from_seed([1,2,3,4]);\n//     main(1);\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\n\n\n\n\n// THIS IS THE BIGNUM VERSION\n\ntype BigNum_2048 = BigNum<18, Test2048Params>;\n\nfn main(x: u8) {\n    let _a: BigNum_2048 = BigNum::__derive_from_seed([x,2,3,4]);\n    let mut a = _a;\n    // let mut b = a;\n    // let mut c = a;\n    for _i in 0..10 {\n        // a = unsafe { a.__add(b) };\n        // b = unsafe { a.__mul(c) };\n        // c = unsafe { c.__mul(c) };\n        // BigNum::evaluate_quadratic_expression([[a]], [[false]], [[b]], [[false]], [c], [true]);\n        a = a.mul(a);\n        // b = b.mul(c);\n        // c = b.mul(a);\n    }\n}\n\n#[test]\nfn test_2048() {\n    // let a: BigNum_2048 = BigNum::__derive_from_seed([1,2,3,4]);\n    main(1);\n}\n\n\n\n\n\n\n\ncomptime fn get_2048_BN_params() -> BigNumParams<18> {\n    let has_multiplicative_inverse = false;\n    let modulus_bits_getter = || 2048;\n    let modulus: [Field; 18] = [\n        0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n        0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n        0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n        0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n        0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n        0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n        0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n        0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n        0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n        0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n        0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n        0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n        0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n        0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n        0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n        0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n        0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n        0x00000000000000000000000000000000000000000000000000000000000000b8\n    ];\n    let redc_param: [Field; 18] = [\n        0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n        0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n        0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n        0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n        0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n        0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n        0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n        0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n        0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n        0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n        0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n        0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n        0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n        0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n        0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n        0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n        0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n        0x0000000000000000000000000000000000000000000000000000000000000162\n    ];\n    BigNumParams::new(\n        has_multiplicative_inverse,\n        modulus_bits_getter,\n        modulus,\n        redc_param\n    )\n}\n\nglobal MY_RUNTIME_BIGNUM_PARAMS: BigNumParams<18> = BigNumParams {\n    has_multiplicative_inverse: false,\n    modulus_bits_getter: || 2048,\n    modulus: [\n        0x0000000000000000000000000000000000c0a197a5ae0fcdceb052c9732614fe,\n        0x0000000000000000000000000000000000656ae034423283422243918ab83be3,\n        0x00000000000000000000000000000000006bf590da48a7c1070b7d5aabaac678,\n        0x00000000000000000000000000000000000cce39f530238b606f24b296e2bda9,\n        0x000000000000000000000000000000000001e1fef9bb9c1c3ead98f226f1bfa0,\n        0x0000000000000000000000000000000000ad8c1c816e12e0ed1379055e373abf,\n        0x0000000000000000000000000000000000cebe80e474f753aa9d1461c435123d,\n        0x0000000000000000000000000000000000aee5a18ceedef88d115a8b93c167ad,\n        0x0000000000000000000000000000000000268ba83c4a65c4307427fc495d9e44,\n        0x0000000000000000000000000000000000dd2777926848667b7df79f342639d4,\n        0x0000000000000000000000000000000000f455074c96855ca0068668efe7da3d,\n        0x00000000000000000000000000000000005ddba6b30bbc168bfb3a1225f27d65,\n        0x0000000000000000000000000000000000591fec484f36707524133bcd6f4258,\n        0x000000000000000000000000000000000059641b756766aeebe66781dd01d062,\n        0x000000000000000000000000000000000058bc5eaff4b165e142bf9e2480eebb,\n        0x0000000000000000000000000000000000667a3964f08e06df772ce64b229a72,\n        0x00000000000000000000000000000000009c1fdb18907711bfe3e3c1cf918395,\n        0x00000000000000000000000000000000000000000000000000000000000000b8\n    ],\n    double_modulus: [0x0181432f4b5c1f9b9d60a592e64c29fc, 0x01cad5c06884650684448723157077c6, 0x01d7eb21b4914f820e16fab557558cef, 0x01199c73ea604716c0de49652dc57b51, 0x0103c3fdf37738387d5b31e44de37f3f, 0x015b183902dc25c1da26f20abc6e757d, 0x019d7d01c8e9eea7553a28c3886a247a, 0x015dcb4319ddbdf11a22b5172782cf5a, 0x014d17507894cb8860e84ff892bb3c88, 0x01ba4eef24d090ccf6fbef3e684c73a7, 0x01e8aa0e992d0ab9400d0cd1dfcfb47a, 0x01bbb74d6617782d17f674244be4faca, 0x01b23fd8909e6ce0ea4826779ade84af, 0x01b2c836eacecd5dd7cccf03ba03a0c3, 0x01b178bd5fe962cbc2857f3c4901dd75, 0x01ccf472c9e11c0dbeee59cc964534e3, 0x01383fb63120ee237fc7c7839f230729, 0x0170],\n    modulus_u60: U60Repr { limbs: [1058436937605846270, 867533891523640540, 153759629660666851, 456743741275973684, 507637211389937272, 486205199909288976, 31284071869103529, 57671168680933558, 1057669653304819616, 8479363271606723, 942229811013040831, 781587600470257166, 764789921859047997, 931092896005715258, 941633352623024045, 787666047433830280, 32695061814550084, 173593660756483139, 828090169652820436, 995989829823268455, 1836635119934013, 1100374146487440842, 863347603192053093, 422698909584572776, 370442216921842264, 401381961810274055, 857486586516983906, 402581472381659886, 90845628438998715, 399630605048551006, 1114408800412146290, 461517352795168877, 1145009151832851349, 703121955796513051, 184, 0] },\n    modulus_u60_x4: U60Repr { limbs: [1058436937605846270, 867533891523640540, 153759629660666851, 456743741275973684, 507637211389937272, 486205199909288976, 31284071869103529, 57671168680933558, 1057669653304819616, 8479363271606723, 942229811013040831, 781587600470257166, 764789921859047997, 931092896005715258, 941633352623024045, 787666047433830280, 32695061814550084, 173593660756483139, 828090169652820436, 995989829823268455, 1836635119934013, 1100374146487440842, 863347603192053093, 422698909584572776, 370442216921842264, 401381961810274055, 857486586516983906, 402581472381659886, 90845628438998715, 399630605048551006, 1114408800412146290, 461517352795168877, 1145009151832851349, 703121955796513051, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] },\n    redc_param: [\n        0x000000000000000000000000000000000091697def7100cd5cf8d890b4ef2ec3,\n        0x00000000000000000000000000000000006765ba8304214dac764d3f4adc3185,\n        0x000000000000000000000000000000000048404bd14d927ea230e60d4bebf940,\n        0x00000000000000000000000000000000007c4d53a23bacc251ecbfc4b7ba5a0b,\n        0x000000000000000000000000000000000093eaf3499474a6f5b2fff83f1259c8,\n        0x00000000000000000000000000000000005bff4c737b97281f1a5f2384a8c16d,\n        0x000000000000000000000000000000000061b4cf2f55358476b5323782999055,\n        0x00000000000000000000000000000000001e7a804e8eacfe3a2a5673bc3885b8,\n        0x0000000000000000000000000000000000eabadeae4282906c817adf70eab4ae,\n        0x0000000000000000000000000000000000166f7df257fe2bf27f0809aceed9b0,\n        0x00000000000000000000000000000000007d90fb7428901b8bed11f6b81e36bf,\n        0x0000000000000000000000000000000000f36e6ba885c60b7024c563605df7e0,\n        0x000000000000000000000000000000000052b7c58d2fb5d2c8478963ae6d4a44,\n        0x000000000000000000000000000000000036ee761de26635f114ccc3f7d74f85,\n        0x0000000000000000000000000000000000e3fb726a10cf2220897513f05243de,\n        0x0000000000000000000000000000000000f43a26bbd732496eb4d828591b8056,\n        0x0000000000000000000000000000000000ff4e42304e60fb3a54fca735499f2c,\n        0x0000000000000000000000000000000000000000000000000000000000000162\n    ]\n};\n\n\n// THIS IS THE RUNTIME-BIGNUM VERSION\n\n// type MyRuntimeBigNum = RuntimeBigNum<18>;\n\n// fn main(x: u8) {\n//     let params = MY_RUNTIME_BIGNUM_PARAMS;\n//     println(params);\n//     let _a: MyRuntimeBigNum = RuntimeBigNum::__derive_from_seed(params, [x,2,3,4]);\n//     let mut a = _a;\n//     // let mut b = a;\n//     // let mut c = a;\n//     for _i in 0..10 {\n//         // a = unsafe { a.__add(b) };\n//         // b = unsafe { a.__mul(c) };\n//         // c = unsafe { c.__mul(c) };\n//         // RuntimeBigNum::evaluate_quadratic_expression(params, [[a]], [[false]], [[b]], [[false]], [c], [true]);\n//         a = a.mul(a);\n//         // b = b.mul(c);\n//         // c = b.mul(a);\n//     }\n// }\n\n// #[test]\n// fn test_2048() {\n//     main(1);\n// }","path":"/Users/mike/git/use/src/main.nr"},"73":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub(crate) struct BigNumParams<let N: u32> {\n    has_multiplicative_inverse: bool,\n\n    // @brief modulus_bits = log2(modulus) rounded up\n    // This needs to be a comptime const, so that it can be used as an argument to std::field::assert_constant()\n    modulus_bits_getter: fn () -> u32,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    modulus_u60: U60Repr<N, 2>,\n    modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    redc_param: [Field; N],\n}\n\n// To be implemented by the user, or within the prebuilt options in the `fields/` dir.\npub(crate) trait BigNumParamsGetter<let N: u32> {\n    fn get_params() -> BigNumParams<N>;\n}\n\n// To be implemented by the user, or within the prebuilt options in the `fields/` dir.\n// pub(crate) trait HasGetModulusBits {\n//     fn get_modulus_bits() -> u32; // This needs to be a comptime const, so that it can be used as an argument to std::field::assert_constant()\n// }\n\n// impl<let N: u32> HasGetModulusBits<N> for BigNumParams<N> {}\n// impl<let N: u32> RuntimeBigNumParamsTrait<N> for BigNumParams<N> {}\n\nimpl<let N: u32> BigNumParams<N> {\n    fn new(\n        has_multiplicative_inverse: bool,\n        modulus_bits_getter: fn() -> u32,\n        modulus: [Field; N],\n        redc_param: [Field; N]\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus_bits_getter,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param\n        }\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n\n// /**\n//  * @brief BigNumParamsGetter defines a \"field\" with which to parametrise BigNum.\n//  * @description The \"field\" does not need to be prime, any value *should* work (TODO: test!)\n// **/\n// trait BigNumParamsGetter<let N: u32> {\n//     fn has_multiplicative_inverse() -> bool;\n//     // @brief modulus_bits = log2(modulus) rounded up\n//     fn modulus_bits() -> u32;\n//     fn modulus() -> [Field; N];\n//     fn modulus_u60() -> U60Repr<N, 2>;\n//     fn modulus_u60_x4() -> U60Repr<N, 4>;\n//     // @brief double_modulus: used when performing negations and subtractions\n//     fn double_modulus() -> [Field; N];\n//     // redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n//     redc_param: [Field; N],\n// }\n\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/params.nr"},"74":{"source":"use crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\nuse crate::constrained_ops::validate_quotient_in_range;\nuse crate::unconstrained_helpers::__barrett_reduction;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<\n    let N: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits_getter(),\n        modulus,\n        params.modulus_u60_x4\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field = mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n            - (borrow_flags[i - 1] * borrow_carry)) * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let M: u32>(\n    params: P<N>,\n    x: [[Field; N]; M],\n    flags: [bool; M]\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<\n    let N: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained pub(crate) fn __compute_quadratic_expression<\n    let N: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // TODO: ugly! Will fail if input slice is empty\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let k  = modulus_bits_getter();\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<\n    let N: u32,\n    let LHS_N: u32,\n    let RHS_N: u32,\n    let NUM_PRODUCTS: u32,\n    let ADD_N: u32\n>(\n    params: P<N>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N]\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range(params, quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size(1);\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size(1);\n        product_limbs[i] += \n            (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size(126); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/expressions.nr"},"75":{"source":"\n// Decomposes a single field into two 120 bit fields and a carry\nunconstrained pub fn split_120_bits(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let offsets: [Field; 17] = [\n        1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000, 0x10000000000000000, 0x1000000000000000000, 0x100000000000000000000, 0x10000000000000000000000, 0x1000000000000000000000000, 0x100000000000000000000000000, 0x10000000000000000000000000000, 0x1000000000000000000000000000000, 0x100000000000000000000000000000000\n    ];\n\n    for i in 0..15 {\n        low += (x_bytes[i] as Field) * offsets[i];\n        high += (x_bytes[i + 15] as Field) * offsets[i];\n    }\n    high += (x_bytes[30] as Field) * offsets[15];\n    high += (x_bytes[31] as Field) * offsets[16];\n    // TDOO: investigate why this is triggered in BigCurve crate? it shouldn't be?\n    //   assert(x_bytes[31] == 0);\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\nunconstrained pub fn split_60_bits(x: Field) -> (u64, u64) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: u64 = 0;\n    let mut high: u64 = 0;\n\n    let offsets: [u64; 8] = [1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000];\n    for i in 0..8 {\n        low += (x_bytes[i] as u64) * offsets[i];\n        high += (x_bytes[i + 8] as u64) * offsets[i];\n    }\n    let t1 = low >> 60;\n    let mask = ((1 as u64) << 60 as u8) - 1;\n    low = low & mask;\n    high = (high << 4) | t1;\n    (low, high)\n}\n\nunconstrained pub(crate) fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i]= lo;\n        inp[i + 1] +=  hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1]= lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/utils/split_bits.nr"},"76":{"source":"use crate::utils::split_bits;\nuse crate::utils::msb::get_msb64;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    limbs: [u64; N * NumSegments]\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe {\n                split_bits::split_60_bits(input[i])\n            };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    unconstrained fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    unconstrained fn into_field_array(x: U60Repr<N, NumSegments>) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i]= x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    unconstrained  fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/utils/u60_representation.nr"},"113":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::unconstrained_helpers::{\n    __validate_in_field_compute_borrow_flags, __validate_gt_remainder, __neg_with_flags,\n    __add_with_flags, __sub_with_flags\n};\nuse crate::unconstrained_ops::{__mul, __div, __udiv_mod};\nuse crate::expressions::evaluate_quadratic_expression;\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(lhs: [Field; N], rhs: [Field; N], predicate: bool) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1] ;\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> bool {\n    let diff = sub(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32>(params: P<N>, val: [Field; N]) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe {\n        __validate_in_field_compute_borrow_flags(params, val)\n    };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i-1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range(params, compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32>(params: P<N>, limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size(120);\n    }\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let final_limb_bits = modulus_bits_getter() - ((N - 1) * 120);\n    limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32>(params: P<N>, limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size(120);\n    }\n    // Note: replace magic number 6 with definition\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let final_limb_bits = modulus_bits_getter() - ((N - 1) * 120) + 6;\n    limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe {\n        __validate_gt_remainder(lhs, rhs)\n    };\n\n    validate_in_range(params, result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1 + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32>(params: P<N>, val: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe {\n        __neg_with_flags(params, val)\n    };\n    validate_in_range(params, result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) = unsafe {\n        __add_with_flags(params, lhs, rhs)\n    };\n    validate_in_range(params, result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0] + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) = unsafe {\n        __sub_with_flags(params, lhs, rhs)\n    };\n    validate_in_range(params, result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    let result = unsafe {\n        __mul(params, lhs, rhs)\n    };\n    evaluate_quadratic_expression(params, [[lhs]], [[false]], [[rhs]], [[false]], [result], [true]);\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse, \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\"\n    );\n    let result = unsafe {\n        __div(params, lhs, rhs)\n    };\n    evaluate_quadratic_expression(params, [[result]], [[false]], [[rhs]], [[false]], [lhs], [true]);\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32>(\n    params: P<N>,\n    numerator: [Field; N],\n    divisor: [Field; N]\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe {\n        __udiv_mod(numerator, divisor)\n    };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false]\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt(params, divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32>(params: P<N>, numerator: [Field; N], divisor: [Field; N]) -> [Field; N] {\n    udiv_mod(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32>(params: P<N>, numerator: [Field; N], divisor: [Field; N]) -> [Field; N] {\n    udiv_mod(params, numerator, divisor).1\n}\n\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/constrained_ops.nr"},"115":{"source":"use crate::utils::u60_representation::U60Repr;\nuse crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\nuse crate::unconstrained_helpers::__barrett_reduction;\n\nunconstrained pub(crate) fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\nunconstrained pub(crate) fn __derive_from_seed<let N: u32, let SeedBytes: u32>(params: P<N>, seed: [u8; SeedBytes]) -> [Field; N] {\n    let mut rolling_seed = seed;\n\n    let mut to_reduce: [Field; 2 * N] = [0; 2 * N];\n\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let modulus_bits = modulus_bits_getter();\n    let mut double_modulus_bits = modulus_bits * 2;\n    let mut double_modulus_bytes = (double_modulus_bits) / 8 + (double_modulus_bits % 8 != 0) as u32;\n\n    let mut last_limb_bytes = double_modulus_bytes % 15;\n    if (last_limb_bytes == 0) {\n        last_limb_bytes = 15;\n    }\n    let mut last_limb_bits = double_modulus_bits % 8;\n    if (last_limb_bits == 0) {\n        last_limb_bits = 8;\n    }\n\n    for i in 0..(N - 1) {\n        let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n        let mut lo: Field = 0;\n        let mut hi: Field = 0;\n        for j in 0..15 {\n            hi *= 256;\n            lo *= 256;\n\n            if (i < 2 * N - 2) {\n                lo += hash[j + 15] as Field;\n                hi += hash[j] as Field;\n            }\n        }\n        to_reduce[2 * i] = lo;\n        to_reduce[2 * i + 1] = hi;\n        rolling_seed[0] += 1;\n    }\n\n    {\n        let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n        let mut hi: Field = 0;\n        for j in 0..(last_limb_bytes - 1) {\n            hi *= 256;\n            hi += hash[j] as Field;\n        }\n        hi *= 256;\n        let last_byte = hash[last_limb_bytes - 1];\n        let mask = (1 as u64 << (last_limb_bits) as u8) - 1;\n        let last_bits = last_byte as u64 & mask;\n        hi += last_bits as Field;\n        to_reduce[2 * N - 2] = hi;\n    }\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let modulus_bits = modulus_bits_getter();\n    let (_, remainder) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        modulus_bits,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n    let result = remainder;\n    result\n}\n\nunconstrained pub(crate) fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\nunconstrained pub(crate) fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\nunconstrained pub(crate) fn __neg<let N: u32>(params: P<N>, limbs: [Field; N]) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\nunconstrained pub(crate) fn __add<let N: u32>(\n    params: P<N>,\n    lhs: [Field; N],\n    rhs: [Field; N]\n) -> [Field; N] {\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\nunconstrained pub(crate) fn __sub<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\nunconstrained pub(crate) fn __mul_with_quotient<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let modulus_bits = modulus_bits_getter();\n    let (q, r) = __barrett_reduction(\n        split_bits::__normalize_limbs(mul, 2 * N),\n        params.redc_param,\n        modulus_bits,\n        params.modulus,\n        params.modulus_u60_x4\n    );\n\n    (q, r)\n}\n\nunconstrained pub(crate) fn __mul<let N: u32>(\n    params: P<N>,\n    lhs: [Field; N],\n    rhs: [Field; N]\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient(params, lhs, rhs);\n    b\n}\n\nunconstrained pub(crate) fn __div<let N: u32>(\n    params: P<N>,\n    numerator: [Field; N],\n    divisor: [Field; N]\n) -> [Field; N] {\n    let inv_divisor = __invmod(params, divisor);\n    __mul(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\nunconstrained pub(crate) fn __udiv_mod<let N: u32>(numerator: [Field; N], divisor: [Field; N]) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\nunconstrained pub(crate) fn __invmod<let N: u32>(params: P<N>, val: [Field; N]) -> [Field; N] {\n    let one: [Field; N] = __one::<N>();\n    let one_u60: U60Repr<N, 2> = U60Repr::from(one);\n    let exp_u60 = params.modulus_u60.sub(one_u60.add(one_u60));\n    let exp = U60Repr::into(exp_u60);\n    __pow(params, val, exp)\n}\n\nunconstrained pub(crate) fn __pow<let N: u32>(\n    params: P<N>,\n    val: [Field; N],\n    exponent: [Field; N]\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let modulus_bits_getter = params.modulus_bits_getter;\n    let modulus_bits = modulus_bits_getter();\n    let num_bits = modulus_bits + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\nunconstrained pub(crate) fn __batch_invert<let N: u32, let M: u32>(params: P<N>, x: [[Field; N]; M]) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul(params, accumulator, temporaries[idx]);\n            accumulator = __mul(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\nunconstrained pub(crate) fn __batch_invert_slice<let N: u32>(params: P<N>, x: [[Field; N]]) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul(params, accumulator, temporaries[idx]);\n            accumulator = __mul(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/unconstrained_ops.nr"},"116":{"source":"use crate::utils::u60_representation::U60Repr;\nuse crate::utils::split_bits;\n\nuse crate::params::BigNumParams as P;\n\nunconstrained pub(crate) fn __validate_in_field_compute_borrow_flags<let N: u32>(params: P<N>, val: [Field; N]) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\nunconstrained pub(crate) fn __validate_gt_remainder<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((b_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - b_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i/2] = carry as bool;\n            borrow_flags[i/2] = borrow as bool;\n        }\n    }\n\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\nunconstrained pub(crate) fn __neg_with_flags<let N: u32>(params: P<N>, val: [Field; N]) -> ([Field; N], [bool; N]) {\n    let x_u60 : U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        borrow = ((x_u60.limbs[i] + borrow_in) > params.modulus_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + params.modulus_u60.limbs[i] - x_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\nunconstrained pub(crate) fn __add_with_flags<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((subtrahend_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - subtrahend_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\nunconstrained pub(crate) fn __sub_with_flags<let N: u32>(params: P<N>, lhs: [Field; N], rhs: [Field; N]) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if underflow {\n        addend_u60 = params.modulus_u60;\n    }\n\n    let mut carry: u64 = 0;\n    let mut carry_in: u64 = 0;\n    let mut borrow: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        carry = (add_term >= 0x1000000000000000) as u64;\n        add_term -= (carry as u64 * 0x1000000000000000);\n        result_u60.limbs[i] = add_term;\n        carry_in = carry as u64;\n        borrow = ((b_u60.limbs[i] + borrow_in) > result_u60.limbs[i]) as u64;\n        let sub = (borrow << 60) + result_u60.limbs[i] - b_u60.limbs[i] - borrow_in;\n        result_u60.limbs[i] = sub;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i/2] = carry as bool;\n            borrow_flags[i/2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\nunconstrained pub(crate) fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>\n) -> ([Field; N], [Field; N]) {\n    let mut mulout: [Field; 3 * N]  = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n    let mut quotient_u60 = mulout_u60.shr((k + k));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n    let mut partial_quotient: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..2 * N {\n        partial_quotient[i] = partial_quotient_full[i];\n    }\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: [Field; 2 * N]  = [0; 2 * N];\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N]  = [0; 2 * N];\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus[i + j] += partial_quotient[i] * modulus[j];\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus[i + 1] += hi;\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    let x_u60 : U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/unconstrained_helpers.nr"},"117":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\nuse crate::constrained_ops::{\n    conditional_select, assert_is_not_equal, eq, validate_in_field, validate_in_range, neg, add, sub,\n    mul, div, udiv_mod, udiv, umod\n};\nuse crate::unconstrained_ops::{\n    __derive_from_seed, __eq, __is_zero, __neg, __add, __sub, __mul, __div, __udiv_mod, __invmod, __pow,\n    __batch_invert, __batch_invert_slice\n};\nuse crate::expressions::{__compute_quadratic_expression, evaluate_quadratic_expression};\nuse crate::serialization::{from_be_bytes, to_le_bytes};\n\npub struct BigNum<let N: u32, Params> {\n    limbs: [Field; N]\n}\n\npub(crate) trait BigNumTrait<let N: u32> {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    fn new() -> Self;\n    fn one() -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_slice(limbs: [Field]) -> Self;\n    fn from_array(limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus() -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N]\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N]\n    );\n\n    fn eq(self, other: Self) -> bool { self == other }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn neg(self) -> Self;\n    fn add(self, other: Self) -> Self { self + other }\n    fn sub(self, other: Self) -> Self { self - other }\n    fn mul(self, other: Self) -> Self { self * other }\n    fn div(self, other: Self) -> Self { self / other }\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, Params> BigNumTrait<N> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    fn from_array(limbs: [Field; N]) -> Self {\n        Self { limbs }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: from_be_bytes(params, x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        let params = Params::get_params();\n        to_le_bytes(params, self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits() -> u32 {\n        let modulus_bits_getter = Params::get_params().modulus_bits_getter;\n        modulus_bits_getter()\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_array(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_array(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_array(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_array(__mul(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_array(__div(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert(params, x.map(|bn| Self::get_limbs(bn))).map(|limbs| Self {limbs})\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice(params, x.map(|bn| Self::get_limbs(bn))).map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression(\n            params,\n            lhs_terms.map(|bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            rhs_terms.map(|bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            linear_terms.map(|bn| Self::get_limbs(bn)),\n            linear_flags\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression(\n            params,\n            lhs_terms.map(|bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            rhs_terms.map(|bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            linear_terms.map(|bn| Self::get_limbs(bn)),\n            linear_flags\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        let params = Params::get_params();\n        validate_in_range(params, self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg(params, self.limbs) }\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, Params> std::ops::Add for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Sub for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Mul for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Div for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, Params> std::cmp::Eq for BigNum<N, Params> where Params: BigNumParamsGetter<N> {\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/Users/mike/nargo/github.com/noir-lang/noir-bignummc/refactor/src/bignum.nr"}},"names":["main"],"brillig_names":["__derive_from_seed","split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags"]}